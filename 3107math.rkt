(define (divides? a b)
  (= 0 (remainder b a)))
(define (congruence-solver a b m)
  (congruence-solver-iter a b m 0 '()))
(define (congruence-solver-iter a b m n result)
  (cond ((= n m) result)
        ((divides? m (- (a n) b))
         (congruence-solver-iter a b m (+ n 1) (cons n result)))
        (else (congruence-solver-iter a b m (+ n 1) result))))
(define (binary-expansion n)
  (define (binary-iter n result)
    (if (= n 1)
        (cons 1 result)
        (binary-iter (floor (/ n 2))
                     (cons (remainder n 2)
                           result))))
  (binary-iter n '()))
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))
(define (filter pred? seq)
  (cond ((null? seq) '())
        ((pred? (car seq)) (cons (car seq)
                                 (filter pred? (cdr seq))))
        (else (filter pred? (cdr seq)))))
(define (length sequence)
  (if (null? sequence)
      0
      (+ 1 (length (cdr sequence)))))
(define (mod-mul x y m)
  (remainder (* x y) m ))
(define (reverse seq)
  (define (reverse-aux lst result)
    (if (null? lst)
        result
        (reverse-aux (cdr lst) (cons (car lst) result))))
  (reverse-aux seq '()))
(define (mod-successive-squaring g m n)
  (define (sucessive-aux g2 count)
    (if (= count n)
        (cons (mod-mul g2 g2 m) '())
        (let ((p (mod-mul g2 g2 m)))
          (cons p (sucessive-aux p (+ count 1))))))
  (cons g (sucessive-aux g 1)))
(define (fast-powering g A m)
  (cond ((= A 0) 1)
        ((= A 1) g)
        (else (let ((bexp (binary-expansion A)))
                (let ((ss-of-g (mod-successive-squaring g m (- (length bexp) 1))))
                  (remainder (accumulate * 1 (filter (lambda (x)
                                                       (not (= x 0)))
                                                     (map (lambda (x y)
                                                            (* x y))
                                                          bexp
                                                          (reverse ss-of-g)))) m))))))
(define (mod-inverse a p)
  (fast-powering a (- p 2) p))
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
(define (euler-phi m)
  (define (euler-iter n)
    (cond ((> n m) 0)
          ((= (gcd m n) 1)
           (+ 1 (euler-iter (+ n 1))))
          (else (euler-iter (+ n 1)))))
  (euler-iter 1))
(define (equiv a b m)
  (= 0 (remainder (- a b) m)))
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
(define (enumerate-x low high n)
  (cond ((= n 1) (enumerate-interval low high))
        ((= n 2) (accumulate append '() (map (lambda (k)
                                               (map (lambda (p)
                                                      (list k p))
                                                    (enumerate-x low high (- n 1))))
                                             (enumerate-x low high 1))))
        (else (accumulate append '() (map (lambda (k)
                                            (map (lambda (p)
                                                   (cons k p))
                                                 (enumerate-x low high (- n 1))))
                                          (enumerate-x low high 1))))))
(define (all-equal? seq)
  (if (or (null? seq) (null? (cdr seq)))
      #t
      (and (= (car seq)
              (cadr seq))
           (all-equal? (cdr seq)))))
(define (nth-element seq n)
  (cond ((null? seq) '())
        ((= n 1) (car seq))
        (else (nth-element (cdr seq) (- n 1)))))
(define (split-into-two seq)
  (define len (/ (length seq) 2))
  (define (split-aux n lim result)
    (if (> n lim)
        result
        (split-aux (+ n 1) lim (cons (nth-element seq n) result))))
  (list (reverse (split-aux 1 len '()))
        (reverse (split-aux (+ len 1) (length seq) '()))))
(define (equal-seq? seq1 seq2)
  (cond ((and (null? seq1) (null? seq2)) #t)
        ((or (null? seq1) (null? seq2)) #f)
        (else (and (= (car seq1) (car seq2))
                   (equal-seq? (cdr seq1) (cdr seq2))))))
(define (mirror-seq? seq)
  (equal-seq? (car (split-into-two seq))
              (cadr (split-into-two seq))))
(define (not-mirror? seq)
  (not (mirror-seq? seq)))
(define (not-all-equal? seq)
  (and (not (all-equal? seq))
       (not-mirror? seq)))
(define (car-stream seq)
  (car seq))
(define (cdr-stream seq)
  (force (cdr seq)))
(define (integers-from x)
  (cons-stream x
               (integers-from (+ x 1))))
(define (display-stream-upto seq x)
  (define (display-aux current count)
    (if (= count x)
        (begin (display (car-stream current))
               (display ")")
               (newline))
        (if (= count 1)
            (begin (display "(")
                   (display (car-stream current))
                   (display " ")
                   (display-aux (cdr-stream current) (+ count 1)))
            (begin (display (car-stream current))
                   (display " ")
                   (display-aux (cdr-stream current) (+ count 1))))))
  (display-aux seq 1))
(define (map-stream proc seq)
  (if (null? seq)
      '()
      (cons-stream (proc (car-stream seq))
                   (map-stream proc (cdr-stream seq)))))
(define (filter-stream pred? seq)
  (cond ((null? seq) '())
        ((pred? (car-stream seq))
         (cons-stream (car-stream seq)
                      (filter-stream pred? (cdr-stream seq))))
        (else (filter-stream pred? (cdr-stream seq)))))
(define (dlp g h p)
  (define (dlp-iter i)
    (if (= i p)
        -1
        (let ((x (fast-powering g i p)))
          (if (= x h)
              i
              (dlp-iter (+ i 1))))))
  (dlp-iter 0))
(define (non-trivial-root? a n)
  (let ((x (fast-powering a 2 n)))
    (if (or (= x 1))
        #t
        #f)))
(define (prime? p)
  (define (prime-iter i)
    (cond ((= i p) #t)
          ((and (not (= i (- p 1))) (non-trivial-root? i p)) #f)
          ((not (= (fast-powering i (- p 1) p) 1)) #f)
          (else (and (prime-iter (+ i 1))))))
  (prime-iter 2))
(define primes (filter-stream prime? (integers-from 2)))
(define (first-prime-that-divides x)
  (car-stream (filter-stream (lambda (j)
                               (divides? j x)) primes)))
(define (prime-factorization x)
  (if (= x 1)
      '()
      (let ((y (first-prime-that-divides x)))
        (cons y
              (prime-factorization (/ x y))))))
(define (except-last seq)
  (if (null? seq)
      '()
      (reverse (cdr (reverse seq)))))
(define (last-element seq)
  (car (reverse seq)))
(define (chinese-remainder-theorem list-of-congruences)
  (cond ((null? list-of-congruences)
         (error ("chinese-remainder-theorem not given any congruences")))
        ((= (length list-of-congruences) 1)
         (car (congruence-solver (caar list-of-congruences)
                                 (cadar list-of-congruences)
                                 (caddar list-of-congruences))))
        
        (else (let ((my-proc (lambda (y)
                               (+ (chinese-remainder-theorem (except-last list-of-congruences))
                                  (* (accumulate *
                                                 1 (map (lambda (pair)
                                                          (nth-element pair 3)) (except-last list-of-congruences))) y)))))
                (let ((possible-solutions (congruence-solver
                                           my-proc
                                           (nth-element (last-element list-of-congruences)
                                                        2)
                                           (nth-element (last-element list-of-congruences) 3))))
                  (if (null? possible-solutions)
                      (display "The congruences have no solution!")
                      (my-proc (car possible-solutions))))))))
(chinese-remainder-theorem (list (list (lambda (x)
                                         x)
                                       7 8)
                                 (list (lambda (x)
                                         x)
                                       3 3)
                                 (list (lambda (x)
                                         x)
                                       1 5)))
(fast-powering 67 111 241)
                                                

                            



      
