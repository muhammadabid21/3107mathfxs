(define (divides? a b)
  (= 0 (remainder b a)))
(define (congruence-solver a b m)
  (congruence-solver-iter a b m 0 '()))
(define (congruence-solver-iter a b m n result)
  (cond ((= n m) result)
        ((divides? m (- (a n) b))
         (congruence-solver-iter a b m (+ n 1) (cons n result)))
        (else (congruence-solver-iter a b m (+ n 1) result))))
(define (binary-expansion n)
  (define (binary-iter n result)
    (if (= n 1)
        (cons 1 result)
        (binary-iter (floor (/ n 2))
                     (cons (remainder n 2)
                           result))))
  (binary-iter n '()))
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))
(define (filter pred? seq)
  (cond ((null? seq) '())
        ((pred? (car seq)) (cons (car seq)
                                 (filter pred? (cdr seq))))
        (else (filter pred? (cdr seq)))))
(define (length sequence)
  (if (null? sequence)
      0
      (+ 1 (length (cdr sequence)))))
(define (mod-mul x y m)
  (remainder (* x y) m ))
(define (reverse seq)
  (define (reverse-aux lst result)
    (if (null? lst)
        result
        (reverse-aux (cdr lst) (cons (car lst) result))))
  (reverse-aux seq '()))
(define (mod-successive-squaring g m n)
  (define (sucessive-aux g2 count)
    (if (= count n)
        (cons (mod-mul g2 g2 m) '())
        (let ((p (mod-mul g2 g2 m)))
          (cons p (sucessive-aux p (+ count 1))))))
  (cons g (sucessive-aux g 1)))
(define (fast-powering g A m)
  (cond ((= A 0) 1)
        ((= A 1) g)
        (else (let ((bexp (binary-expansion A)))
                (let ((ss-of-g (mod-successive-squaring g m (- (length bexp) 1))))
                  (remainder (accumulate * 1 (filter (lambda (x)
                                                       (not (= x 0)))
                                                     (map (lambda (x y)
                                                            (* x y))
                                                          bexp
                                                          (reverse ss-of-g)))) m))))))
(define (mod-inverse a p)
  (if (prime? p)
      (fast-powering a (- p 2) p)
      (let ((inverse (congruence-solver (lambda (x)
                                         (* x a))
                                        1
                                        p)))
        (if (null? inverse)
            -1
            (car inverse)))))
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
(define (euler-phi m)
  (define (euler-iter n)
    (cond ((> n m) 0)
          ((= (gcd m n) 1)
           (+ 1 (euler-iter (+ n 1))))
          (else (euler-iter (+ n 1)))))
  (euler-iter 1))
(define (equiv a b m)
  (= 0 (remainder (- a b) m)))
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
(define (enumerate-x low high n)
  (cond ((= n 1) (enumerate-interval low high))
        ((= n 2) (accumulate append '() (map (lambda (k)
                                               (map (lambda (p)
                                                      (list k p))
                                                    (enumerate-x low high (- n 1))))
                                             (enumerate-x low high 1))))
        (else (accumulate append '() (map (lambda (k)
                                            (map (lambda (p)
                                                   (cons k p))
                                                 (enumerate-x low high (- n 1))))
                                          (enumerate-x low high 1))))))
(define (all-equal? seq)
  (if (or (null? seq) (null? (cdr seq)))
      #t
      (and (= (car seq)
              (cadr seq))
           (all-equal? (cdr seq)))))
(define (nth-element seq n)
  (cond ((null? seq) '())
        ((= n 1) (car seq))
        (else (nth-element (cdr seq) (- n 1)))))
(define (split-into-two seq)
  (define len (/ (length seq) 2))
  (define (split-aux n lim result)
    (if (> n lim)
        result
        (split-aux (+ n 1) lim (cons (nth-element seq n) result))))
  (list (reverse (split-aux 1 len '()))
        (reverse (split-aux (+ len 1) (length seq) '()))))
(define (equal-seq? seq1 seq2)
  (cond ((and (null? seq1) (null? seq2)) #t)
        ((or (null? seq1) (null? seq2)) #f)
        (else (and (= (car seq1) (car seq2))
                   (equal-seq? (cdr seq1) (cdr seq2))))))
(define (mirror-seq? seq)
  (equal-seq? (car (split-into-two seq))
              (cadr (split-into-two seq))))
(define (not-mirror? seq)
  (not (mirror-seq? seq)))
(define (not-all-equal? seq)
  (and (not (all-equal? seq))
       (not-mirror? seq)))
(define (car-stream seq)
  (car seq))
(define (cdr-stream seq)
  (force (cdr seq)))
(define (integers-from x)
  (cons-stream x
               (integers-from (+ x 1))))
(define (display-stream-upto seq x)
  (define (display-aux current count)
    (if (= count x)
        (begin (display (car-stream current))
               (display ")")
               (newline))
        (if (= count 1)
            (begin (display "(")
                   (display (car-stream current))
                   (display " ")
                   (display-aux (cdr-stream current) (+ count 1)))
            (begin (display (car-stream current))
                   (display " ")
                   (display-aux (cdr-stream current) (+ count 1))))))
  (display-aux seq 1))
(define (map-stream proc seq)
  (if (null? seq)
      '()
      (cons-stream (proc (car-stream seq))
                   (map-stream proc (cdr-stream seq)))))
(define (filter-stream pred? seq)
  (cond ((null? seq) '())
        ((pred? (car-stream seq))
         (cons-stream (car-stream seq)
                      (filter-stream pred? (cdr-stream seq))))
        (else (filter-stream pred? (cdr-stream seq)))))
(define (dlp g h p)
  (define (dlp-iter i)
    (if (= i p)
        -1
        (let ((x (fast-powering g i p)))
          (if (= x h)
              i
              (dlp-iter (+ i 1))))))
  (dlp-iter 0))
(define (non-trivial-root? a n)
  (let ((x (fast-powering a 2 n)))
    (if (or (= x 1))
        #t
        #f)))
(define (prime? p)
  (define (prime-iter i)
    (cond ((= i p) #t)
          ((and (not (= i (- p 1))) (non-trivial-root? i p)) #f)
          ((not (= (fast-powering i (- p 1) p) 1)) #f)
          (else (and (prime-iter (+ i 1))))))
  (prime-iter 2))
(define (sieve stream)
  (cons-stream
   (car-stream stream)
   (sieve (filter-stream
           (lambda (x)
             (not (divides? (car-stream stream) x)))
           (cdr-stream stream)))))
(define primes (sieve (integers-from 2)))
(define (first-prime-that-divides x)
  (car-stream (filter-stream (lambda (j)
                               (divides? j x)) primes)))
(define (prime-factorization x)
  (if (= x 1)
      '()
      (let ((y (first-prime-that-divides x)))
        (cons y
              (prime-factorization (/ x y))))))
(define (except-last seq)
  (if (null? seq)
      '()
      (reverse (cdr (reverse seq)))))
(define (last-element seq)
  (car (reverse seq)))
(define (chinese-remainder-theorem list-of-congruences)
  (cond ((null? list-of-congruences)
         (error ("chinese-remainder-theorem not given any congruences")))
        ((= (length list-of-congruences) 1)
         (car (congruence-solver (caar list-of-congruences)
                                 (cadar list-of-congruences)
                                 (caddar list-of-congruences))))
        
        (else (let ((my-proc (lambda (y)
                               (+ (chinese-remainder-theorem (except-last list-of-congruences))
                                  (* (accumulate *
                                                 1 (map (lambda (pair)
                                                          (nth-element pair 3)) (except-last list-of-congruences))) y)))))
                (let ((possible-solutions (congruence-solver
                                           my-proc
                                           (nth-element (last-element list-of-congruences)
                                                        2)
                                           (nth-element (last-element list-of-congruences) 3))))
                  (if (null? possible-solutions)
                      (display "The congruences have no solution!")
                      (my-proc (car possible-solutions))))))))
(define (extended-euclidean-solver a b)
  (define (extended-aux u g x y)
    (if (= y 0)
        (list g u (/ (- g (* a u)) b))
        (extended-aux x y
                      (- u (* (floor (/ g y)) x))
                      (- g (* (floor (/ g y)) y)))))
  (cdr (extended-aux 1 a 0 b)))
(define (nth-stream-element seq n)
  (if (= n 1)
      (car-stream seq)
      (nth-stream-element (cdr-stream seq) (- n 1))))
(define (order x p)
  (define (order-aux i)
    (cond ((> i p))
          ((= (fast-powering x i p) 1) i)
          (else (order-aux (+ i 1)))))
  (order-aux 1))

(define (all-ones? seq)
  (if (null? seq)
      #t
      (if (not (= 1 (car seq)))
          #f
          (all-ones? (cdr seq)))))
(define (number-of-occurences x seq)
  (if (null? seq)
      0
      (if (= x (car seq))
          (+ 1 (number-of-occurences x (cdr seq)))
          (number-of-occurences x (cdr seq)))))
(define (prime-factorization2 n)
  (define (prime-fact-iter seq)
    (if (null? seq)
        '()
        (cons (list (car seq)
                    (number-of-occurences (car seq) seq))
              (prime-fact-iter (filter (lambda (x)
                                         (not (= x (car seq))))
                                       seq)))))
  (prime-fact-iter (prime-factorization n)))
(define (pohlig-hellman g h p)
  (let ((N (order g p)))
    (let ((prime-facts (prime-factorization2 N)))
      (let ((step-one (map (lambda (x)
                             (dlp (fast-powering g (/ N (fast-powering (car x)
                                                                       (cadr x)
                                                                       p)) p)
                                  (fast-powering h (/ N (fast-powering (car x)
                                                                       (cadr x)
                                                                       p)) p)
                                  p)) prime-facts)))
        (chinese-remainder-theorem (map (lambda (j y)
                                          (list (lambda (x)
                                                  x)
                                                j
                                                (fast-powering (car y) (cadr y) p)))
                                        step-one prime-facts))))))        
(define (mersenne-prime? p)
  (let ((b-exp (binary-expansion p)))
    (and (all-ones? b-exp)
         (prime? (length b-exp)))))
(define (pohlig-with-mersenne-primes p g h)
  (if (not (mersenne-prime? p))
      (error "The given prime is not a Mersenne prime:" p)
      (pohlig-hellman g h p)))
(define (contains-duplicates? seq)
  (cond ((null? seq) #f)
        ((> (number-of-occurences (car seq) seq) 1) #t)
        (else (contains-duplicates? (cdr seq)))))
(define (mobius x)
  (if (not (contains-duplicates? (prime-factorization x)))
      1
      0))
(define (factorial n)
  (if (or (= n 0) (= n 1))
      1
      (* n (factorial (- n 1)))))
(define (even? n)
  (= 0 (remainder n 2)))
(define (square x)
  (* x x))
(define (semi-fast-powering base exp)
  (cond ((= 0 exp) 1)
        ((= 1 exp) base)
        ((even? exp)
         (semi-fast-powering (square base) (/ exp 2)))
        (else (* base (semi-fast-powering base (- exp 1))))))
(define (pollard-factorization N)
  (define temp (cons 0 0))
  (define (pollard-with-steps count)
    (let ((a (- (fast-powering 2 (factorial (+ count 1)) N) 1)))
      (let ((g (gcd a N)))
        (if (= g 1)
            (pollard-with-steps (+ count 1))
            (begin (set-car! temp g)
                   (set-cdr! temp count))))))
  (pollard-with-steps 1)
  (display "The factorization of ")
  (display N)
  (display " is ")
  (display "p = ")
  (display (car temp))
  (display " and ")
  (display "q = ")
  (display (/ N (car temp)))
  (display ", ")
  (display "and it took ")
  (display (+ (* 2(cdr temp)) 1))
  (display " steps.")
  (newline))



          